"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function ifUnOrNan(string) {
    if (!string) {
        return '';
    }
    else {
        return string;
    }
}
function splitСolon(string) {
    const first = ifUnOrNan(string.split(':')[0]);
    const second = ifUnOrNan(string.split(':')[1]);
    return { first, second };
}
function atSignExists(proxy) {
    if (/@/.test(proxy)) {
        return true;
    }
    else {
        return false;
    }
}
function replaceLocalhost(proxy) {
    return proxy.replace('localhost', 'local.host') + '';
}
function returnLocalhost(proxy) {
    return proxy.replace('local.host', 'localhost') + '';
}
function noProtocol(proxy) {
    return proxy.replace(/.*(?<=\:\/\/)/, '') + '';
}
function getLoginPassword(proxy) {
    const newProxy = noProtocol(replaceLocalhost(proxy));
    if (atSignExists(proxy)) {
        const atSignEnd = /(?<=@).*/.exec(newProxy) + '';
        if (/\./.test(atSignEnd)) {
            const loginPassword = splitСolon(/.*(?=@)/.exec(newProxy) + '');
            return { login: loginPassword.first, password: loginPassword.second };
        }
        else {
            const loginPassword = splitСolon(/(?<=@).*/.exec(newProxy) + '');
            return { login: loginPassword.first, password: loginPassword.second };
        }
    }
    else {
        return { login: '', password: '' };
    }
}
function getProtocol(proxy) {
    if (/\:\/\//.test(proxy)) {
        const protocol = /.*(?=\:\/\/)/.exec(proxy) + '';
        return { protocol: protocol };
    }
    else {
        return { protocol: '' };
    }
}
function getHostPort(proxy) {
    const newProxy = noProtocol(replaceLocalhost(proxy));
    if (atSignExists(proxy)) {
        const atSignEnd = /(?<=@).*/.exec(newProxy) + '';
        if (/\./.test(atSignEnd)) {
            const proxyAtSign = /(?<=@).*/.exec(newProxy) + '';
            const host = splitСolon(proxyAtSign).first;
            const port = splitСolon(proxyAtSign).second;
            return { host, port };
        }
        else {
            const proxyAtSign = /.*(?=@)/.exec(newProxy) + '';
            const host = splitСolon(proxyAtSign).first;
            const port = splitСolon(proxyAtSign).second;
            return { host, port };
        }
    }
    else {
        const host = splitСolon(newProxy).first;
        const port = splitСolon(newProxy).second;
        return { host, port };
    }
}
function removeEmpty(obj) {
    Object.keys(obj).forEach((key) => {
        if (Object.prototype.toString.call(obj[key]) === '[object Date]' &&
            (obj[key].toString().length === 0 ||
                obj[key].toString() === 'Invalid Date')) {
            delete obj[key];
        }
        else if (obj[key] && typeof obj[key] === 'object') {
            removeEmpty(obj[key]);
        }
        else if (obj[key] == null ||
            obj[key] === '' ||
            obj[key] === 0 ||
            obj[key] === ':') {
            delete obj[key];
        }
        if (obj[key] &&
            typeof obj[key] === 'object' &&
            Object.keys(obj[key]).length === 0 &&
            Object.prototype.toString.call(obj[key]) !== '[object Date]') {
            delete obj[key];
        }
    });
    return obj;
}
function ifEmptyAssignDefault(proxyObject) {
    if (!proxyObject.host) {
        Object.assign(proxyObject, { host: 'localhost' });
    }
    if (!proxyObject.port) {
        Object.assign(proxyObject, { port: 80 });
    }
    return proxyObject;
}
function axiosMod(proxyObject) {
    const axiosObject = {
        host: proxyObject.host,
        port: Number(proxyObject.port),
        auth: { username: proxyObject.login, password: proxyObject.password },
        protocol: proxyObject.protocol
    };
    return ifEmptyAssignDefault(removeEmpty(axiosObject));
}
function nodeTunnelMod(proxyObject) {
    const nodeTunnelObject = {
        host: proxyObject.host,
        port: Number(proxyObject.port),
        proxyAuth: proxyObject.login + ':' + proxyObject.password
    };
    return ifEmptyAssignDefault(removeEmpty(nodeTunnelObject));
}
function createSplitProxy(proxy, options) {
    const login = getLoginPassword(proxy).login;
    const password = getLoginPassword(proxy).password;
    const protocol = getProtocol(proxy).protocol;
    const host = returnLocalhost(getHostPort(proxy).host);
    const port = getHostPort(proxy).port;
    const finalProxyObject = {
        protocol: protocol,
        host: host,
        port: port,
        login: login,
        password: password
    };
    switch (options.mode) {
        case 'axios': {
            return axiosMod(finalProxyObject);
        }
        case 'node-tunnel': {
            return nodeTunnelMod(finalProxyObject);
        }
        case 'default': {
            return finalProxyObject;
        }
        default: {
            return finalProxyObject;
        }
    }
}
const defaultOptions = {
    mode: 'default'
};
function splitProxy(proxy, options) {
    return createSplitProxy(proxy, Object.assign(defaultOptions, options));
}
module.exports = splitProxy;
exports.default = splitProxy;
